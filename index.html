<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Solar System Simulation</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            cursor: grab;
            touch-action: none; /* Prevent default touch actions */
        }
        
        body.grabbing {
            cursor: grabbing;
        }
        
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            padding: 15px;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            pointer-events: none;
        }
        
        #info h1 {
            font-size: 24px;
            font-weight: 500;
            letter-spacing: 2px;
            margin-bottom: 8px;
            color: #fff;
        }
        
        #info p {
            font-size: 14px;
            color: #aaa;
            letter-spacing: 0.5px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(15, 15, 15, 0.9);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            max-width: calc(100% - 40px);
            touch-action: manipulation; /* Prevent touch events from propagating */
        }
        
        button {
            margin: 5px;
            padding: 12px 18px;
            background: rgba(40, 40, 40, 0.8);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 0.3px;
            min-height: 44px; /* Minimum touch target size */
            display: inline-block;
            touch-action: manipulation; /* Improve touch responsiveness */
        }
        
        button:hover {
            background: rgba(60, 60, 60, 0.8);
            color: #fff;
        }
        
        button:active {
            background: rgba(30, 30, 30, 0.8);
        }
        
        #speedControl {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            touch-action: manipulation; /* Prevent touch events from propagating */
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #aaa;
            letter-spacing: 0.3px;
            font-weight: 400;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px; /* Increased height for better touch */
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            touch-action: manipulation; /* Prevent touch events from propagating */
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px; /* Increased size for better touch */
            height: 20px;
            background: #444;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px; /* Increased size for better touch */
            height: 20px;
            background: #444;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #planetInfo {
            position: absolute;
            top: 50%;
            right: -350px;
            transform: translateY(-50%);
            z-index: 100;
            background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(20px);
            padding: 30px;
            border-radius: 12px;
            max-width: 320px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.6);
            transition: right 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            user-select: text; /* Allow text selection */
            max-height: 80vh; /* Limit height on mobile */
            overflow-y: auto; /* Add scroll for long content */
        }
        
        #planetInfo.show {
            right: 20px;
        }
        
        #planetInfo h3 {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 15px;
            color: #fff;
            letter-spacing: 0.5px;
        }
        
        #planetInfo p {
            font-size: 14px;
            line-height: 1.5;
            color: #ccc;
            margin-bottom: 20px;
        }
        
        #planetInfo .details {
            margin-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            padding-top: 20px;
        }
        
        #planetInfo .detail-row {
            display: flex;
            flex-direction: row;
            margin-bottom: 10px;
            font-size: 13px;
        }
        
        #planetInfo .detail-label {
            color: #888;
            font-weight: 400;
            width: 120px;
            flex-shrink: 0;
        }
        
        #planetInfo .detail-value {
            color: #ddd;
            font-weight: 500;
            margin-left: 10px;
            flex-grow: 1;
        }
        
        #planetInfo .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px; /* Increased size for better touch */
            height: 32px;
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 0;
            margin: 0;
            min-height: 32px; /* Ensure minimum touch target size */
            touch-action: manipulation; /* Improve touch responsiveness */
        }
        
        #planetInfo .close-btn:hover {
            background: rgba(60, 60, 60, 0.8);
        }
        
        #planetInfo .close-btn::before,
        #planetInfo .close-btn::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 1px;
            background: #ccc;
        }
        
        #planetInfo .close-btn::before {
            transform: rotate(45deg);
        }
        
        #planetInfo .close-btn::after {
            transform: rotate(-45deg);
        }
        
        /* Minimalist Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }
        
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #loadingText {
            font-size: 18px;
            font-weight: 300;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 40px;
            text-transform: uppercase;
        }
        
        #progressBar {
            width: 180px;
            height: 3px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        #progressFill {
            height: 100%;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.8));
            width: 0%;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 3px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
        
        #loadingPercent {
            margin-top: 20px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 1px;
            font-weight: 300;
        }
        
        /* Planet labels styling - simplified without box */
        .planet-label {
            position: absolute;
            color: white;
            font-size: 12px;
            font-weight: 400;
            letter-spacing: 1px;
            text-transform: uppercase;
            /* Changed from pointer-events: none to allow clicking */
            pointer-events: auto;
            transform: translate(-50%, -50%);
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            z-index: 10;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            cursor: pointer;
            transition: font-weight 0.2s ease;
            opacity: 0.8;
        }
        
        /* Changed hover effect for planet labels - now makes text bold instead of yellow */
        .planet-label:hover {
            font-weight: 600;
            opacity: 1;
        }
        
        /* Mobile-specific adjustments */
        @media (max-width: 768px) {
            #controls {
                bottom: 10px;
                left: 10px;
                right: 10px;
                padding: 15px;
            }
            
            button {
                padding: 10px 12px;
                font-size: 12px;
                margin: 3px;
            }
            
            #planetInfo {
                max-width: calc(100% - 40px);
                padding: 20px;
                right: -100%; /* Start completely off-screen */
            }
            
            #planetInfo.show {
                right: 10px; /* Show with smaller margin on mobile */
            }
            
            #info h1 {
                font-size: 20px;
            }
            
            #info p {
                font-size: 12px;
            }
            
            #loadingText {
                font-size: 16px;
                letter-spacing: 2px;
            }
            
            #progressBar {
                width: 140px;
                height: 2px;
            }
            
            .planet-label {
                font-size: 10px;
            }
            
            /* Mobile info arrow button */
            #infoArrow {
                position: absolute;
                right: 15px;
                top: 50%;
                transform: translateY(-50%);
                width: 40px;
                height: 40px;
                background: rgba(40, 40, 40, 0.9);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 50%;
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 99;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            }
            
            #infoArrow.show {
                display: flex;
            }
            
            #infoArrow:hover {
                background: rgba(60, 60, 60, 0.9);
                transform: translateY(-50%) scale(1.1);
            }
            
            #infoArrow::before {
                content: '';
                width: 0;
                height: 0;
                border-top: 6px solid transparent;
                border-bottom: 6px solid transparent;
                border-left: 10px solid #fff;
            }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div id="loadingText">Loading</div>
        <div id="progressBar">
            <div id="progressFill"></div>
        </div>
        <div id="loadingPercent">0%</div>
    </div>
    
    <div id="info">
        <h1>SOLAR SYSTEM</h1>
        <p>Click and drag to rotate • Scroll to zoom • Click on a planet or its name to explore</p>
    </div>
    
    <div id="controls">
        <button id="toggleOrbits">Toggle Orbits</button>
        <button id="toggleLabels">Toggle Labels</button>
        <button id="resetView">Reset View</button>
        <div id="speedControl">
            <label for="speedSlider">Simulation Speed: <span id="speedValue">1</span>x</label>
            <input type="range" id="speedSlider" min="0" max="10" step="0.1" value="1">
        </div>
    </div>
    
    <!-- Mobile info arrow button -->
    <div id="infoArrow"></div>
    
    <div id="planetInfo">
        <button class="close-btn" id="closePlanetInfoBtn"></button>
        <h3 id="planetName"></h3>
        <p id="planetDetails"></p>
        <div class="details" id="planetData"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Detect if we're on a mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Determine device performance level
        const devicePerformanceLevel = isMobile ? 
            (navigator.hardwareConcurrency && navigator.hardwareConcurrency > 4 ? 'medium' : 'low') : 'high';
        
        // Set quality based on device performance
        const qualitySettings = {
            low: {
                planetSegments: 24,
                orbitSegments: 48,
                ringSegments: 24,
                starCount: 3000,
                antialias: false,
                pixelRatio: 1.5,
                shadows: false
            },
            medium: {
                planetSegments: 32,
                orbitSegments: 64,
                ringSegments: 32,
                starCount: 5000,
                antialias: true,
                pixelRatio: 2,
                shadows: false
            },
            high: {
                planetSegments: 48,
                orbitSegments: 96,
                ringSegments: 48,
                starCount: 10000,
                antialias: true,
                pixelRatio: 2,
                shadows: true
            }
        };
        
        const quality = qualitySettings[devicePerformanceLevel];
        
        // Loading animation
        const loadingText = document.getElementById('loadingText');
        const progressFill = document.getElementById('progressFill');
        const loadingPercent = document.getElementById('loadingPercent');
        const loadingScreen = document.getElementById('loading');
        
        let loadingDots = 0;
        let loadingInterval = setInterval(() => {
            loadingDots = (loadingDots + 1) % 4;
            loadingText.textContent = 'Loading' + '.'.repeat(loadingDots);
        }, 600);
        
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: quality.antialias,
            alpha: true
        });
        
        // Enable better rendering settings for natural appearance
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = quality.shadows;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, quality.pixelRatio));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0; // Natural exposure
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.physicallyCorrectLights = true;
        document.body.appendChild(renderer.domElement);

        // Enhanced lighting system for natural appearance
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Natural ambient light
        scene.add(ambientLight);

        // Main sun light with natural intensity
        const sunLight = new THREE.PointLight(0xffffff, 2.5, 1000); // Natural intensity
        sunLight.position.set(0, 0, 0);
        sunLight.castShadow = quality.shadows;
        if (quality.shadows) {
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
        }
        scene.add(sunLight);

        // Add subtle fill lights for natural illumination
        const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.5); // Natural fill light
        fillLight1.position.set(50, 20, 50);
        scene.add(fillLight1);

        const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.3); // Subtle fill light
        fillLight2.position.set(-50, 20, -50);
        scene.add(fillLight2);

        // Camera position
        camera.position.set(0, 50, 100);
        camera.lookAt(0, 0, 0);

        // Camera controls
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let targetCameraDistance = 100;
        let currentCameraDistance = 100;
        let cameraRotationX = 0;
        let cameraRotationY = 0;
        let cameraHeight = 50;
        let targetCameraHeight = 50;
        let focusingOnPlanet = false;
        let focusedPlanet = null;
        let transitionProgress = 0;
        let transitionDuration = 2000;
        let transitionStartTime = 0;
        let initialCameraPosition = new THREE.Vector3();
        let targetCameraPosition = new THREE.Vector3();
        let initialLookAt = new THREE.Vector3();
        let targetLookAt = new THREE.Vector3();
        let planetCameraOffset = new THREE.Vector3(); // New variable to store offset from planet to camera
        
        // Planet focus zoom controls
        let planetFocusDistance = 5; // Default distance multiplier from planet
        let minPlanetFocusDistance = 2; // Minimum distance multiplier
        let maxPlanetFocusDistance = 15; // Maximum distance multiplier

        // Smooth camera movement
        const damping = 0.05;
        
        // Raycaster for planet selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Occlusion raycaster for label visibility
        const occlusionRaycaster = new THREE.Raycaster();

        // Simulation speed with smoothing
        let simulationSpeed = 1;
        let targetSimulationSpeed = 1;
        const speedDamping = 0.1; // How quickly speed changes
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        
        // Track if user is dragging speed slider
        let isDraggingSpeedSlider = false;
        
        // Track if user is interacting with planet info panel
        let isInteractingWithPlanetInfo = false;
        
        // Track if info panel is visible
        let isInfoPanelVisible = false;
        
        // Track if we have a selected planet (for mobile)
        let selectedPlanet = null;
        
        // Touch event variables
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartDistance = 0;
        let isTouching = false;
        let isPinching = false;
        
        // Speed slider event listeners - Fixed for mobile
        speedSlider.addEventListener('input', (e) => {
            targetSimulationSpeed = parseFloat(e.target.value);
            speedValue.textContent = targetSimulationSpeed.toFixed(1);
        });
        
        // Enhanced slider touch handling
        speedSlider.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isDraggingSpeedSlider = true;
            document.body.style.touchAction = 'none'; // Prevent all touch actions while dragging slider
        }, { passive: false });
        
        speedSlider.addEventListener('touchmove', (e) => {
            e.preventDefault();
            e.stopPropagation();
            // Update value based on touch position
            const rect = speedSlider.getBoundingClientRect();
            const percent = Math.max(0, Math.min(1, (e.touches[0].clientX - rect.left) / rect.width));
            const value = percent * 10; // Range is 0-10
            speedSlider.value = value;
            targetSimulationSpeed = parseFloat(value);
            speedValue.textContent = targetSimulationSpeed.toFixed(1);
        }, { passive: false });
        
        speedSlider.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isDraggingSpeedSlider = false;
            document.body.style.touchAction = ''; // Restore touch actions
        }, { passive: false });
        
        // Prevent camera rotation when dragging speed slider
        speedSlider.addEventListener('mousedown', () => {
            isDraggingSpeedSlider = true;
        });
        
        document.addEventListener('mouseup', () => {
            isDraggingSpeedSlider = false;
        });

        // Planet data with updated texture URLs
        const planetData = [
            {
                name: 'Sun',
                radius: 5,
                distance: 0,
                rotationSpeed: 0.0002, // Reduced from 0.0005 (40% of previous speed)
                info: 'The Sun is the star at the center of our Solar System. It is a nearly perfect sphere of hot plasma, with internal convective motion that generates a magnetic field.',
                texture: 'https://upload.wikimedia.org/wikipedia/commons/a/a4/Solarsystemscope_texture_8k_sun.jpg',
                details: {
                    'Type': 'G-type main-sequence star',
                    'Diameter': '1.39 million km',
                    'Mass': '1.989 × 10^30 kg',
                    'Surface Temp': '5,778 K (5,505°C)',
                    'Core Temp': '15 million °C',
                    'Age': '4.6 billion years',
                    'Luminosity': '3.828 × 10^26 watts',
                    'Rotation Period': '25-35 Earth days at equator',
                    'Composition': '73% Hydrogen, 25% Helium'
                }
            },
            {
                name: 'Mercury',
                radius: 0.2,
                distance: 10,
                rotationSpeed: 0.0004, // Reduced from 0.001 (40% of previous speed)
                orbitSpeed: 0.008, // Reduced from 0.02 (40% of previous speed)
                info: 'Mercury is the smallest planet in our Solar System and the closest to the Sun. Its orbit around the Sun takes 87.97 Earth days.',
                texture: 'https://upload.wikimedia.org/wikipedia/commons/2/27/Solarsystemscope_texture_8k_mercury.jpg',
                details: {
                    'Type': 'Terrestrial planet',
                    'Diameter': '4,879 km',
                    'Mass': '3.301 × 10^23 kg',
                    'Orbital Period': '88 Earth days',
                    'Day Length': '59 Earth days',
                    'Moons': '0',
                    'Surface Temp': '-173°C to 427°C',
                    'Atmosphere': 'Minimal (O2, Na, K, Ar, He, etc.)',
                    'Gravity': '3.7 m/s² (38% of Earth\'s)',
                    'Notable': 'No atmosphere, extreme temperature variations'
                }
            },
            {
                name: 'Venus',
                radius: 0.5,
                distance: 15,
                rotationSpeed: 0.0002, // Reduced from 0.0005 (40% of previous speed)
                orbitSpeed: 0.003, // Reduced from 0.0075 (40% of previous speed)
                info: 'Venus is the second planet from the Sun. It is named after the Roman goddess of love and beauty. It is the hottest planet in our Solar System.',
                texture: 'https://upload.wikimedia.org/wikipedia/commons/1/1c/Solarsystemscope_texture_8k_venus_surface.jpg',
                details: {
                    'Type': 'Terrestrial planet',
                    'Diameter': '12,104 km',
                    'Mass': '4.867 × 10^24 kg',
                    'Orbital Period': '225 Earth days',
                    'Day Length': '243 Earth days (retrograde)',
                    'Moons': '0',
                    'Surface Temp': '462°C average',
                    'Atmosphere': '96.5% Carbon dioxide, 3.5% Nitrogen',
                    'Pressure': '92 times Earth\'s',
                    'Notable': 'Hottest planet, rotates backwards'
                }
            },
            {
                name: 'Earth',
                radius: 0.5,
                distance: 20,
                rotationSpeed: 0.004, // Reduced from 0.01 (40% of previous speed)
                orbitSpeed: 0.002, // Reduced from 0.005 (40% of previous speed)
                info: 'Earth is the third planet from the Sun and the only astronomical object known to harbor life. About 71% of Earth\'s surface is made up of the ocean.',
                texture: 'https://upload.wikimedia.org/wikipedia/commons/0/04/Solarsystemscope_texture_8k_earth_daymap.jpg',
                details: {
                    'Type': 'Terrestrial planet',
                    'Diameter': '12,742 km',
                    'Mass': '5.972 × 10^24 kg',
                    'Orbital Period': '365.25 days',
                    'Day Length': '24 hours',
                    'Moons': '1 (Moon)',
                    'Surface Temp': '-88°C to 58°C',
                    'Atmosphere': '78% Nitrogen, 21% Oxygen',
                    'Gravity': '9.8 m/s²',
                    'Notable': 'Only planet with liquid water on surface'
                }
            },
            {
                name: 'Mars',
                radius: 0.3,
                distance: 25,
                rotationSpeed: 0.0036, // Reduced from 0.009 (40% of previous speed)
                orbitSpeed: 0.0016, // Reduced from 0.004 (40% of previous speed)
                info: 'Mars is the fourth planet from the Sun and the second-smallest planet in the Solar System. It is often called the "Red Planet".',
                texture: 'https://upload.wikimedia.org/wikipedia/commons/7/70/Solarsystemscope_texture_8k_mars.jpg',
                details: {
                    'Type': 'Terrestrial planet',
                    'Diameter': '6,779 km',
                    'Mass': '6.417 × 10^23 kg',
                    'Orbital Period': '687 Earth days',
                    'Day Length': '24.6 hours',
                    'Moons': '2 (Phobos, Deimos)',
                    'Surface Temp': '-143°C to 35°C',
                    'Atmosphere': '95% Carbon dioxide, 3% Nitrogen, Argon',
                    'Gravity': '3.71 m/s² (38% of Earth\'s)',
                    'Notable': 'Largest volcano in Solar System (Olympus Mons)'
                }
            },
            {
                name: 'Jupiter',
                radius: 2,
                distance: 40,
                rotationSpeed: 0.008, // Reduced from 0.02 (40% of previous speed)
                orbitSpeed: 0.0004, // Reduced from 0.001 (40% of previous speed)
                info: 'Jupiter is the fifth planet from the Sun and the largest in the Solar System. It is a gas giant with a mass one-thousandth that of the Sun.',
                texture: 'https://upload.wikimedia.org/wikipedia/commons/5/5e/Solarsystemscope_texture_8k_jupiter.jpg',
                details: {
                    'Type': 'Gas giant',
                    'Diameter': '139,820 km',
                    'Mass': '1.898 × 10^27 kg',
                    'Orbital Period': '11.86 Earth years',
                    'Day Length': '9.9 hours',
                    'Moons': '95 known (including 4 Galilean)',
                    'Cloud Top Temp': '-108°C',
                    'Atmosphere': '90% Hydrogen, 10% Helium',
                    'Gravity': '24.79 m/s² (2.53 times Earth\'s)',
                    'Notable': 'Great Red Spot storm (300+ years old)',
                    'Magnetic Field': 'Strongest in Solar System'
                }
            },
            {
                name: 'Saturn',
                radius: 1.7,
                distance: 55,
                rotationSpeed: 0.0076, // Reduced from 0.019 (40% of previous speed)
                orbitSpeed: 0.00018, // Reduced from 0.00045 (40% of previous speed)
                info: 'Saturn is the sixth planet from the Sun and the second-largest in the Solar System. It is a gas giant with a spectacular ring system.',
                texture: 'https://upload.wikimedia.org/wikipedia/commons/e/ea/Solarsystemscope_texture_2k_saturn.jpg',
                hasRing: true,
                ringTexture: 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Saturn_Rings.png/500px-Saturn_Rings.png',
                details: {
                    'Type': 'Gas giant',
                    'Diameter': '116,460 km',
                    'Mass': '5.683 × 10^26 kg',
                    'Orbital Period': '29.46 Earth years',
                    'Day Length': '10.7 hours',
                    'Moons': '146 known (including Titan)',
                    'Cloud Top Temp': '-139°C',
                    'Atmosphere': '96% Hydrogen, 3% Helium',
                    'Gravity': '10.44 m/s²',
                    'Notable': 'Most spectacular ring system, less dense than water',
                    'Ring Particles': 'Mostly ice particles, some rock'
                }
            },
            {
                name: 'Uranus',
                radius: 0.8,
                distance: 70,
                rotationSpeed: 0.006, // Reduced from 0.015 (40% of previous speed)
                orbitSpeed: 0.00008, // Reduced from 0.0002 (40% of previous speed)
                info: 'Uranus is the seventh planet from the Sun. It has the third-largest planetary radius and fourth-largest planetary mass in the Solar System.',
                texture: 'https://upload.wikimedia.org/wikipedia/commons/9/95/Solarsystemscope_texture_2k_uranus.jpg',
                details: {
                    'Type': 'Ice giant',
                    'Diameter': '50,724 km',
                    'Mass': '8.681 × 10^25 kg',
                    'Orbital Period': '84 Earth years',
                    'Day Length': '17.2 hours',
                    'Moons': '27 known (including Titania, Oberon)',
                    'Cloud Top Temp': '-197°C',
                    'Atmosphere': '83% Hydrogen, 15% Helium, 2% Methane',
                    'Gravity': '8.87 m/s² (0.9 times Earth\'s)',
                    'Notable': 'Extreme axial tilt (98°), rotates sideways',
                    'Discovery': '1781 by William Herschel'
                }
            },
            {
                name: 'Neptune',
                radius: 0.8,
                distance: 85,
                rotationSpeed: 0.0064, // Reduced from 0.016 (40% of previous speed)
                orbitSpeed: 0.00002, // Reduced from 0.00005 (40% of previous speed)
                info: 'Neptune is the eighth and outermost planet in the Solar System. It is the fourth-largest planet by diameter and the third-largest by mass.',
                texture: 'https://upload.wikimedia.org/wikipedia/commons/1/1e/Solarsystemscope_texture_2k_neptune.jpg',
                details: {
                    'Type': 'Ice giant',
                    'Diameter': '49,244 km',
                    'Mass': '1.024 × 10^26 kg',
                    'Orbital Period': '165 Earth years',
                    'Day Length': '16.1 hours',
                    'Moons': '16 known (including Triton)',
                    'Cloud Top Temp': '-201°C',
                    'Atmosphere': '80% Hydrogen, 19% Helium, 1% Methane',
                    'Gravity': '11.15 m/s² (1.14 times Earth\'s)',
                    'Notable': 'Fastest winds in Solar System (2,100 km/h)',
                    'Discovery': '1846 by Johann Galle',
                    'Color': 'Deep blue from methane absorption'
                }
            }
        ];

        // Create planets
        const planets = [];
        const orbits = [];
        const labels = [];
        let showOrbits = true;
        let showLabels = true;
        
        // Track planet rotation and orbit angles
        const planetAngles = [];
        planetData.forEach(data => {
            planetAngles.push({
                rotation: 0,
                orbit: 0
            });
        });

        // Load textures first
        const textureLoader = new THREE.TextureLoader();
        const loadedTextures = {};
        let texturesLoaded = 0;
        const totalTextures = planetData.length;
        
        // Function to update loading progress
        function updateLoadingProgress() {
            // Fix: Calculate progress correctly from 0 to 100
            const progress = Math.min(100, Math.floor((texturesLoaded / totalTextures) * 100));
            progressFill.style.width = progress + '%';
            loadingPercent.textContent = progress + '%';
            
            // When all textures are loaded, hide loading screen
            if (texturesLoaded >= totalTextures) {
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 1000);
                }, 500);
            }
        }

        planetData.forEach((data, index) => {
            // Create planet with adaptive detail based on device performance
            const geometry = new THREE.SphereGeometry(data.radius, quality.planetSegments, quality.planetSegments);
            
            // Natural material without artificial colors or glowing effects
            let material;
            
            if (data.name === 'Sun') {
                // Special material for the Sun
                material = new THREE.MeshBasicMaterial({
                    emissive: 0xffff00,
                    emissiveIntensity: 1,
                    map: null // Will be loaded separately
                });
            } else {
                // Use MeshStandardMaterial with natural properties
                material = new THREE.MeshStandardMaterial({
                    roughness: 0.8, // Natural roughness
                    metalness: 0.0, // No metalness
                    map: null // Will be loaded separately
                });
            }
            
            // Load texture with natural settings
            textureLoader.load(data.texture, (texture) => {
                texture.encoding = THREE.sRGBEncoding;
                texture.generateMipmaps = true;
                texture.minFilter = THREE.LinearMipmapLinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                
                // Center the texture properly for Earth
                if (data.name === 'Earth') {
                    texture.center.set(0.5, 0.5);
                }
                
                material.map = texture;
                material.needsUpdate = true;
                texturesLoaded++;
                updateLoadingProgress();
            }, undefined, () => {
                console.log(`Failed to load texture for ${data.name}`);
                texturesLoaded++;
                updateLoadingProgress();
            });
            
            const planet = new THREE.Mesh(geometry, material);
            if (quality.shadows && data.name !== 'Sun') {
                planet.castShadow = true;
                planet.receiveShadow = true;
            }
            planet.userData = data;
            scene.add(planet);
            planets.push(planet);

            // Create orbit with adaptive detail
            if (data.distance > 0) {
                const orbitGeometry = new THREE.RingGeometry(data.distance - 0.1, data.distance + 0.1, quality.orbitSegments);
                const orbitMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x666666, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                orbit.rotation.x = Math.PI / 2;
                scene.add(orbit);
                orbits.push(orbit);
            }

            // Create label with simplified styling
            const labelDiv = document.createElement('div');
            labelDiv.textContent = data.name;
            labelDiv.className = 'planet-label';
            labelDiv.dataset.planetIndex = index; // Store planet index for click handling
            document.body.appendChild(labelDiv);
            labels.push(labelDiv);

            // Add Saturn's ring with the new texture and adjusted color
            if (data.hasRing) {
                const ringGeometry = new THREE.RingGeometry(data.radius * 1.5, data.radius * 2.5, quality.ringSegments);
                
                // Match Saturn's color for better integration
                const saturnColor = new THREE.Color(0xfad5a5);
                const ringColor = new THREE.Color();
                ringColor.copy(saturnColor);
                ringColor.multiplyScalar(0.6); // Make rings 60% as bright as Saturn
                
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: ringColor, // Match Saturn's color
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7, // Reduced from 0.9 for less brightness
                    map: null // Will be loaded separately
                });
                
                // Load the ring texture
                textureLoader.load(data.ringTexture, (ringTexture) => {
                    ringTexture.encoding = THREE.sRGBEncoding;
                    ringTexture.generateMipmaps = true;
                    ringTexture.minFilter = THREE.LinearMipmapLinearFilter;
                    ringTexture.magFilter = THREE.LinearFilter;
                    ringTexture.wrapS = THREE.RepeatWrapping;
                    ringTexture.wrapT = THREE.RepeatWrapping;
                    
                    ringMaterial.map = ringTexture;
                    ringMaterial.needsUpdate = true;
                    texturesLoaded++;
                    updateLoadingProgress();
                }, undefined, () => {
                    console.log(`Failed to load ring texture for ${data.name}`);
                    texturesLoaded++;
                    updateLoadingProgress();
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                planet.add(ring);
            }
        });

        // Create stars background with adaptive count
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({ 
            color: 0xffffff, 
            size: 0.2,
            sizeAttenuation: true
        });
        const starsVertices = [];
        for (let i = 0; i < quality.starCount; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            starsVertices.push(x, y, z);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Function to check if a planet is occluded by other planets
        function isPlanetOccluded(planet, camera) {
            // Get the position of the planet in world space
            const planetPosition = new THREE.Vector3();
            planet.getWorldPosition(planetPosition);
            
            // Create a vector from the camera to the planet
            const direction = new THREE.Vector3().subVectors(planetPosition, camera.position).normalize();
            
            // Create a raycaster from the camera towards the planet
            occlusionRaycaster.set(camera.position, direction);
            
            // Check for intersections with all planets except the current one
            const intersects = occlusionRaycaster.intersectObjects(planets.filter(p => p !== planet));
            
            // If there's an intersection and it's closer than the planet, the planet is occluded
            if (intersects.length > 0) {
                const intersectionDistance = intersects[0].distance;
                const planetDistance = camera.position.distanceTo(planetPosition);
                
                // If the intersection is closer than the planet, it's occluded
                return intersectionDistance < planetDistance;
            }
            
            return false;
        }

        // Event listeners
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('wheel', onMouseWheel);
        document.addEventListener('click', onMouseClick);
        window.addEventListener('resize', onWindowResize);
        
        // Touch event listeners for mobile
        document.addEventListener('touchstart', onTouchStart, { passive: false });
        document.addEventListener('touchmove', onTouchMove, { passive: false });
        document.addEventListener('touchend', onTouchEnd);

        // Button controls - Fixed for mobile
        document.getElementById('toggleOrbits').addEventListener('click', toggleOrbits);
        document.getElementById('toggleOrbits').addEventListener('touchend', function(e) {
            e.preventDefault();
            toggleOrbits();
        });
        
        document.getElementById('toggleLabels').addEventListener('click', toggleLabels);
        document.getElementById('toggleLabels').addEventListener('touchend', function(e) {
            e.preventDefault();
            toggleLabels();
        });
        
        document.getElementById('resetView').addEventListener('click', resetView);
        document.getElementById('resetView').addEventListener('touchend', function(e) {
            e.preventDefault();
            resetView();
        });
        
        // Close button for planet info - Fixed for mobile
        document.getElementById('closePlanetInfoBtn').addEventListener('click', closePlanetInfo);
        document.getElementById('closePlanetInfoBtn').addEventListener('touchend', function(e) {
            e.preventDefault();
            closePlanetInfo();
        });
        
        // Info arrow button for mobile
        const infoArrow = document.getElementById('infoArrow');
        infoArrow.addEventListener('click', function() {
            if (selectedPlanet) {
                showPlanetInfo(selectedPlanet);
                infoArrow.classList.remove('show');
            }
        });
        
        infoArrow.addEventListener('touchend', function(e) {
            e.preventDefault();
            if (selectedPlanet) {
                showPlanetInfo(selectedPlanet);
                infoArrow.classList.remove('show');
            }
        });

        function toggleOrbits() {
            showOrbits = !showOrbits;
            orbits.forEach(orbit => orbit.visible = showOrbits);
        }

        function toggleLabels() {
            showLabels = !showLabels;
            labels.forEach(label => label.style.display = showLabels ? 'block' : 'none');
        }

        function resetView() {
            focusingOnPlanet = false;
            focusedPlanet = null;
            selectedPlanet = null;
            transitionProgress = 0;
            targetCameraDistance = 100;
            targetCameraHeight = 50;
            targetRotationX = 0;
            targetRotationY = 0;
            closePlanetInfo();
            
            // Hide info arrow on mobile
            if (isMobile) {
                infoArrow.classList.remove('show');
            }
        }

        // Track when mouse enters/leaves planet info panel
        const planetInfoElement = document.getElementById('planetInfo');
        planetInfoElement.addEventListener('mouseenter', () => {
            isInteractingWithPlanetInfo = true;
        });
        
        planetInfoElement.addEventListener('mouseleave', () => {
            isInteractingWithPlanetInfo = false;
        });
        
        // Track when info panel is shown/hidden
        planetInfoElement.addEventListener('transitionend', () => {
            // Check if panel is visible or hidden after transition
            isInfoPanelVisible = planetInfoElement.classList.contains('show');
        });

        function onMouseDown(event) {
            // Only track mouse down for camera rotation if not on speed slider or planet info panel
            if (!isDraggingSpeedSlider && !isInteractingWithPlanetInfo) {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
                document.body.classList.add('grabbing');
            }
        }

        function onMouseMove(event) {
            if (isMouseDown && !isInteractingWithPlanetInfo) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                // Fixed: Inverted horizontal rotation
                targetRotationY -= deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                // Limit vertical rotation
                targetRotationX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, targetRotationX));
                
                mouseX = event.clientX;
                mouseY = event.clientY;
                
                // If focusing on a planet, update offset vector based on the new rotation
                if (focusingOnPlanet && focusedPlanet) {
                    const planetRadius = focusedPlanet.userData.radius;
                    const distanceFromPlanet = planetRadius * planetFocusDistance;
                    
                    // Calculate the new offset based on the rotation angles
                    planetCameraOffset.x = distanceFromPlanet * Math.sin(targetRotationY) * Math.cos(targetRotationX);
                    planetCameraOffset.y = distanceFromPlanet * Math.sin(targetRotationX);
                    planetCameraOffset.z = distanceFromPlanet * Math.cos(targetRotationY) * Math.cos(targetRotationX);
                }
            }
        }

        function onMouseUp() {
            isMouseDown = false;
            document.body.classList.remove('grabbing');
        }

        function onMouseWheel(event) {
            event.preventDefault();
            
            // Increased zoom speed for mobile
            const zoomSpeed = isMobile ? 0.15 : 0.05;
            
            if (focusingOnPlanet) {
                // Zoom when focusing on a planet
                if (event.deltaY < 0) {
                    // Zoom in
                    planetFocusDistance *= (1 - zoomSpeed);
                } else {
                    // Zoom out
                    planetFocusDistance *= (1 + zoomSpeed);
                }
                
                // Clamp the distance to reasonable values
                planetFocusDistance = Math.max(minPlanetFocusDistance, Math.min(maxPlanetFocusDistance, planetFocusDistance));
                
                // Update the offset vector based on the new distance
                if (focusedPlanet) {
                    const planetRadius = focusedPlanet.userData.radius;
                    const distanceFromPlanet = planetRadius * planetFocusDistance;
                    const currentOffset = new THREE.Vector3().subVectors(camera.position, focusedPlanet.position).normalize();
                    planetCameraOffset.copy(currentOffset.multiplyScalar(distanceFromPlanet));
                }
            } else {
                // Regular zoom for the solar system view
                if (event.deltaY < 0) {
                    // Zoom in
                    targetCameraDistance *= (1 - zoomSpeed);
                } else {
                    // Zoom out
                    targetCameraDistance *= (1 + zoomSpeed);
                }
                
                // Clamp the distance to reasonable values
                targetCameraDistance = Math.max(10, Math.min(200, targetCameraDistance));
            }
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planets);

            if (intersects.length > 0) {
                const clickedPlanet = intersects[0].object;
                
                // Check if this is the same planet we're already focusing on
                if (focusedPlanet === clickedPlanet) {
                    // If it's the same planet, just show the info panel if it's closed
                    if (!isInfoPanelVisible) {
                        if (isMobile) {
                            // On mobile, show the arrow instead of the panel directly
                            infoArrow.classList.add('show');
                        } else {
                            // On desktop, show the panel directly
                            showPlanetInfo(clickedPlanet);
                        }
                    }
                    return; // Don't re-focus on the same planet
                }
                
                // If it's a different planet or no planet is currently focused, focus on the new one
                if (isMobile) {
                    // On mobile, store the selected planet and show the arrow
                    selectedPlanet = clickedPlanet;
                    infoArrow.classList.add('show');
                } else {
                    // On desktop, show the panel directly
                    showPlanetInfo(clickedPlanet);
                }
                
                focusOnPlanet(clickedPlanet);
            }
        }
        
        // Touch event handlers for mobile
        function onTouchStart(event) {
            // Don't handle touch if we're dragging the slider
            if (isDraggingSpeedSlider) {
                event.preventDefault();
                return;
            }
            
            event.preventDefault();
            
            if (event.touches.length === 1) {
                // Single touch - start rotation
                isTouching = true;
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                document.body.classList.add('grabbing');
            } else if (event.touches.length === 2) {
                // Two touches - start pinch zoom
                isPinching = true;
                isTouching = false;
                
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }
        
        function onTouchMove(event) {
            // Don't handle touch if we're dragging the slider
            if (isDraggingSpeedSlider) {
                event.preventDefault();
                return;
            }
            
            event.preventDefault();
            
            if (isTouching && event.touches.length === 1) {
                // Single touch - rotate
                const deltaX = event.touches[0].clientX - touchStartX;
                const deltaY = event.touches[0].clientY - touchStartY;
                
                targetRotationY -= deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                // Limit vertical rotation
                targetRotationX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, targetRotationX));
                
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                
                // If focusing on a planet, update offset vector based on the new rotation
                if (focusingOnPlanet && focusedPlanet) {
                    const planetRadius = focusedPlanet.userData.radius;
                    const distanceFromPlanet = planetRadius * planetFocusDistance;
                    
                    // Calculate the new offset based on the rotation angles
                    planetCameraOffset.x = distanceFromPlanet * Math.sin(targetRotationY) * Math.cos(targetRotationX);
                    planetCameraOffset.y = distanceFromPlanet * Math.sin(targetRotationX);
                    planetCameraOffset.z = distanceFromPlanet * Math.cos(targetRotationY) * Math.cos(targetRotationX);
                }
            } else if (isPinching && event.touches.length === 2) {
                // Two touches - pinch zoom - Increased zoom speed for mobile
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Increased zoom sensitivity for mobile
                const zoomSpeed = isMobile ? 0.15 : 0.05; // Increased from 0.05 to 0.15 for mobile
                const zoomFactor = (distance - touchStartDistance) * zoomSpeed;
                
                if (focusingOnPlanet) {
                    // Zoom when focusing on a planet
                    planetFocusDistance *= (1 - zoomFactor * 0.02);
                    
                    // Clamp the distance to reasonable values
                    planetFocusDistance = Math.max(minPlanetFocusDistance, Math.min(maxPlanetFocusDistance, planetFocusDistance));
                    
                    // Update the offset vector based on the new distance
                    if (focusedPlanet) {
                        const planetRadius = focusedPlanet.userData.radius;
                        const distanceFromPlanet = planetRadius * planetFocusDistance;
                        const currentOffset = new THREE.Vector3().subVectors(camera.position, focusedPlanet.position).normalize();
                        planetCameraOffset.copy(currentOffset.multiplyScalar(distanceFromPlanet));
                    }
                } else {
                    // Regular zoom for the solar system view
                    targetCameraDistance *= (1 - zoomFactor * 0.02);
                    
                    // Clamp the distance to reasonable values
                    targetCameraDistance = Math.max(10, Math.min(200, targetCameraDistance));
                }
                
                touchStartDistance = distance;
            }
        }
        
        function onTouchEnd(event) {
            // Don't handle touch if we're dragging the slider
            if (isDraggingSpeedSlider) {
                event.preventDefault();
                return;
            }
            
            event.preventDefault();
            
            if (event.touches.length === 0) {
                // All fingers lifted
                isTouching = false;
                isPinching = false;
                document.body.classList.remove('grabbing');
                
                // Check for tap (quick touch without movement)
                if (Math.abs(event.changedTouches[0].clientX - touchStartX) < 5 && 
                    Math.abs(event.changedTouches[0].clientY - touchStartY) < 5) {
                    // This was a tap, handle planet selection
                    handleTouchTap(event.changedTouches[0]);
                }
            } else if (event.touches.length === 1 && isPinching) {
                // Changed from pinch to single touch
                isPinching = false;
                isTouching = true;
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }
        }
        
        function handleTouchTap(touch) {
            // Convert touch position to normalized device coordinates
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planets);

            if (intersects.length > 0) {
                const clickedPlanet = intersects[0].object;
                
                // Check if this is the same planet we're already focusing on
                if (focusedPlanet === clickedPlanet) {
                    // If it's the same planet, just show the info panel if it's closed
                    if (!isInfoPanelVisible) {
                        // On mobile, show the arrow instead of the panel directly
                        infoArrow.classList.add('show');
                    }
                    return; // Don't re-focus on the same planet
                }
                
                // If it's a different planet or no planet is currently focused, focus on the new one
                // On mobile, store the selected planet and show the arrow
                selectedPlanet = clickedPlanet;
                infoArrow.classList.add('show');
                
                focusOnPlanet(clickedPlanet);
            }
        }

        function showPlanetInfo(planet) {
            const planetInfo = document.getElementById('planetInfo');
            const planetName = document.getElementById('planetName');
            const planetDetails = document.getElementById('planetDetails');
            const planetDataDiv = document.getElementById('planetData');

            planetName.textContent = planet.userData.name;
            planetDetails.textContent = planet.userData.info;
            
            // Clear previous data
            planetDataDiv.innerHTML = '';
            
            // Add detailed information
            if (planet.userData.details) {
                for (const [key, value] of Object.entries(planet.userData.details)) {
                    const detailRow = document.createElement('div');
                    detailRow.className = 'detail-row';
                    
                    const detailLabel = document.createElement('span');
                    detailLabel.className = 'detail-label';
                    detailLabel.textContent = key + ':';
                    
                    const detailValue = document.createElement('span');
                    detailValue.className = 'detail-value';
                    detailValue.textContent = value;
                    
                    detailRow.appendChild(detailLabel);
                    detailRow.appendChild(detailValue);
                    planetDataDiv.appendChild(detailRow);
                }
            }
            
            planetInfo.classList.add('show');
        }

        function closePlanetInfo() {
            const planetInfo = document.getElementById('planetInfo');
            planetInfo.classList.remove('show');
            
            // On mobile, show the arrow again when closing the panel
            if (isMobile && selectedPlanet) {
                infoArrow.classList.add('show');
            }
        }

        function focusOnPlanet(planet) {
            focusingOnPlanet = true;
            focusedPlanet = planet;
            transitionStartTime = Date.now();
            transitionProgress = 0;
            
            // Reset planet focus distance when focusing on a new planet
            planetFocusDistance = 5;
            
            // Store initial camera position and look at
            initialCameraPosition.copy(camera.position);
            
            // Calculate the current look-at point based on camera orientation
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const distance = camera.position.length();
            initialLookAt.copy(camera.position).add(direction.multiplyScalar(distance));
            
            // Calculate target position relative to the new planet
            const planetRadius = planet.userData.radius;
            const distanceFromPlanet = planetRadius * planetFocusDistance;
            
            // Calculate the target position based on current camera angles relative to the planet
            targetCameraPosition.x = planet.position.x + distanceFromPlanet * Math.sin(targetRotationY) * Math.cos(targetRotationX);
            targetCameraPosition.y = planet.position.y + distanceFromPlanet * Math.sin(targetRotationX);
            targetCameraPosition.z = planet.position.z + distanceFromPlanet * Math.cos(targetRotationY) * Math.cos(targetRotationX);
            
            targetLookAt.copy(planet.position);
            
            // Store the offset vector from planet to camera
            planetCameraOffset = new THREE.Vector3().subVectors(targetCameraPosition, planet.position);
        }

        function updateCameraPosition() {
            // Smooth camera movement
            cameraRotationX += (targetRotationX - cameraRotationX) * damping;
            cameraRotationY += (targetRotationY - cameraRotationY) * damping;
            currentCameraDistance += (targetCameraDistance - currentCameraDistance) * damping;
            cameraHeight += (targetCameraHeight - cameraHeight) * damping;
            
            if (focusingOnPlanet && focusedPlanet) {
                // Calculate transition progress
                const elapsed = Date.now() - transitionStartTime;
                transitionProgress = Math.min(elapsed / transitionDuration, 1);
                
                // Use easing function for smooth transition
                const easedProgress = easeInOutCubic(transitionProgress);
                
                // Calculate target camera position using the offset vector
                targetCameraPosition.addVectors(focusedPlanet.position, planetCameraOffset);
                
                // Interpolate camera position directly between current and target
                camera.position.lerpVectors(initialCameraPosition, targetCameraPosition, easedProgress);
                
                // Calculate the current look-at point by interpolating between initial and target
                const currentLookAt = new THREE.Vector3();
                currentLookAt.lerpVectors(initialLookAt, focusedPlanet.position, easedProgress);
                camera.lookAt(currentLookAt);
                
                // When transition is complete, continue following the planet
                if (transitionProgress >= 1) {
                    camera.position.addVectors(focusedPlanet.position, planetCameraOffset);
                    camera.lookAt(focusedPlanet.position);
                }
            } else {
                // Fixed: Proper orbital camera movement without zoom effect
                // Calculate camera position on a sphere
                const x = currentCameraDistance * Math.sin(cameraRotationY) * Math.cos(cameraRotationX);
                const y = currentCameraDistance * Math.sin(cameraRotationX);
                const z = currentCameraDistance * Math.cos(cameraRotationY) * Math.cos(cameraRotationX);
                
                camera.position.set(x, y, z);
                camera.lookAt(0, 0, 0);
            }
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Smoothly adjust simulation speed
            simulationSpeed += (targetSimulationSpeed - simulationSpeed) * speedDamping;

            // Rotate planets and update positions
            planets.forEach((planet, index) => {
                const data = planetData[index];
                
                // Update rotation and orbit angles based on speed
                planetAngles[index].rotation += data.rotationSpeed * simulationSpeed;
                
                // Orbit around sun
                if (data.distance > 0) {
                    planetAngles[index].orbit += data.orbitSpeed * simulationSpeed;
                    planet.position.x = Math.cos(planetAngles[index].orbit) * data.distance;
                    planet.position.z = Math.sin(planetAngles[index].orbit) * data.distance;
                }
                
                // Apply rotation
                planet.rotation.y = planetAngles[index].rotation;

                // Update label position with offset to right and up
                if (labels[index]) {
                    // Calculate the 3D position of the planet
                    const planetWorldPosition = new THREE.Vector3();
                    planet.getWorldPosition(planetWorldPosition);
                    
                    // Project to screen coordinates
                    const vector = planetWorldPosition.clone();
                    vector.project(camera);
                    
                    // Convert to screen coordinates
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
                    
                    // Apply offset to move label to the right and up
                    const offsetX = isMobile ? 15 : 20;
                    const offsetY = isMobile ? -15 : -20;
                    
                    labels[index].style.left = `${x + offsetX}px`;
                    labels[index].style.top = `${y + offsetY}px`;
                    
                    // Check if the planet is occluded by other planets
                    const isOccluded = isPlanetOccluded(planet, camera);
                    
                    // Hide label if focusing on this planet or if it's occluded
                    if (focusedPlanet === planet || isOccluded) {
                        labels[index].style.display = 'none';
                        labels[index].style.pointerEvents = 'none'; // Disable click events
                    } else {
                        labels[index].style.display = showLabels && vector.z < 1 ? 'block' : 'none';
                        labels[index].style.pointerEvents = 'auto'; // Enable click events
                    }
                }
            });

            // Update camera position with smooth movement
            updateCameraPosition();

            renderer.render(scene, camera);
        }

        // Add event listeners for planet labels
        labels.forEach((label, index) => {
            // Handle click events for planet labels
            label.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event from bubbling up
                
                const planet = planets[index];
                
                // Check if this is the same planet we're already focusing on
                if (focusedPlanet === planet) {
                    // If it's the same planet, just show the info panel if it's closed
                    if (!isInfoPanelVisible) {
                        if (isMobile) {
                            // On mobile, show the arrow instead of the panel directly
                            infoArrow.classList.add('show');
                        } else {
                            // On desktop, show the panel directly
                            showPlanetInfo(planet);
                        }
                    }
                    return; // Don't re-focus on the same planet
                }
                
                // If it's a different planet or no planet is currently focused, focus on the new one
                if (isMobile) {
                    // On mobile, store the selected planet and show the arrow
                    selectedPlanet = planet;
                    infoArrow.classList.add('show');
                } else {
                    // On desktop, show the panel directly
                    showPlanetInfo(planet);
                }
                
                focusOnPlanet(planet);
            });
            
            // Handle touch events for mobile
            label.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const planet = planets[index];
                
                // Check if this is the same planet we're already focusing on
                if (focusedPlanet === planet) {
                    // If it's the same planet, just show the info panel if it's closed
                    if (!isInfoPanelVisible) {
                        // On mobile, show the arrow instead of the panel directly
                        infoArrow.classList.add('show');
                    }
                    return; // Don't re-focus on the same planet
                }
                
                // If it's a different planet or no planet is currently focused, focus on the new one
                // On mobile, store the selected planet and show the arrow
                selectedPlanet = planet;
                infoArrow.classList.add('show');
                
                focusOnPlanet(planet);
            });
        });

        animate();
    </script>
</body>
</html>
